#!/usr/bin/env python
"""Dump stubs for six.moves, bypassing the lazy logic.

This script is compatible with python2 and python3.
"""

from __future__ import print_function

from functools import partial
import importlib
import os
import six
import sys
import types

repo = 'https://github.com/o11c/stubtool'

errors = 0

def makedirs(dir):
    if not os.path.isdir(dir):
        os.makedirs(dir)

def do_out(outdir, name, mod, fun, ext='.pyi'):
    out = os.path.join(outdir, *name.split('.'))
    try:
        is_package = hasattr(mod, '__path__')
    except ImportError as e:
        if name == 'six.moves.dbm_gnu':
            is_package = False
        elif name == 'six.moves.tkinter':
            is_package = True
        elif name.startswith('six.moves.tkinter_'):
            is_package = False
        else:
            global errors
            errors += 1
            print('ERROR   %s: %s' % (name, e))
            return
    if is_package:
        out = os.path.join(out, '__init__')
    out += ext
    makedirs(os.path.dirname(out))
    with open(out, 'w') as out:
        print('# Stubs for %s (python %d.%d)' % ((name,) + sys.version_info[:2]), file=out)
        warning = 'DO NOT EDIT'
        print('# Generated by %s, %s' % (os.path.basename(sys.argv[0]), warning), file=out)
        print('# See %s' % repo, file=out)
        print(file=out)
        fun(out, mod)

def do0(out, mod):
    assert mod.__name__ == 'six.moves.urllib'
    p = partial(print, file=out)
    for name in dir(mod):
        attr = getattr(mod, name)
        assert isinstance(attr, six._LazyModule), '%s is a %s' % (name, type(attr).mro())
        p('import %s.%s as %s' % (mod.__name__, name, name))

def do1(out, mod):
    p = partial(print, file=out)
    p('from %s import (' % mod.__name__)
    for a in mod._moved_attributes:
        name = a.name
        assert not name.startswith('__')
        p('    %s as %s,' % (name, name))
    p(')')

def do2(out, mod):
    p = partial(print, file=out)
    for a in mod._moved_attributes:
        if isinstance(a, six.MovedModule):
            assert '%s.%s' % (mod.__name__, a.name) in six._importer.known_modules
            p('import %s.%s as %s' % (mod.__name__, a.name, a.name))
            continue
        assert isinstance(a, six.MovedAttribute)
        p('from %s import %s as %s' % (a.mod, a.attr, a.name))

def do3(out, mod):
    p = partial(print, file=out)
    if True:
        p("# Note, glob imports only work in .py files, not .pyi files.")
        p('from %s import *' % mod.mod)
    else:
        p("# This might require manual fixup between minor releases.")
        try:
            m = importlib.import_module(mod.mod)
        except ImportError as e:
            global errors
            errors += 1
            print('ERROR   %s: %s' % (mod.name, e))
            p('# Error: unable to import on this installation!')
            return
        if sys.version_info[0] == 2 and hasattr(m, 'print'):
            p('from __future__ import print_function')
            p()
        keywords = {'None', '__debug__'}
        if sys.version_info[0] >= 3:
            keywords |= {'True', 'False'}
        for a in dir(m):
            # Use individual `from` lines to make manual fixup easier.
            c = '#' if a in keywords else ''
            p('%sfrom %s import %s as %s' % (c, mod.mod, a, a))

def main(outdir):
    for name, mod in sorted(six._importer.known_modules.items()):
        assert name.startswith('six.moves.') or name == 'six.moves'
        if isinstance(mod, six._LazyModule):
            if name != mod.__name__:
                print('LINK    %s -> %s' % (name, mod.__name__))
                do_out(outdir, name, mod, do1)
            else:
                print('ATTRS   %s' % name)
                do_out(outdir, name, mod, do2)
        elif isinstance(mod, types.ModuleType):
            print('MANUAL  %s' % name)
            assert name == mod.__name__
            do_out(outdir, name, mod, do0)
        elif isinstance(mod, six.MovedModule):
            print('GLOB    %s -> %s' % (name, mod.mod))
            # Need `import as` in a .pyi file, but we don't know all the contents.
            do_out(outdir, name, mod, do3, ext='.py')
        else:
            assert False, type(mod).mro()
    if errors:
        sys.exit('Incomplete - %d import errors' % errors)
    else:
        print('Everything is Ok.')

# Useful for interactive use.
def __repr__(self):
    return 'MovedModule(name=%s, mod=%s)' % (self.name, self.mod)
six.MovedModule.__repr__ = __repr__
def __repr__(self):
    return 'MovedAttribute(name=%s, mod=%s, attr=%s)' % (self.name, self.mod, self.attr)
six.MovedAttribute.__repr__ = __repr__
del __repr__

if __name__ == '__main__':
    if len(sys.argv) != 2 or sys.argv[1].startswith('-'):
        sys.exit('Usage: %s third_party/<version>' % sys.argv[0])
    main(sys.argv[1])
